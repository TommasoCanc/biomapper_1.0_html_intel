# nameCheck and nameSuggest check for the wrong names and suggest for correct names.
# hunspell_check and hunspell_suggest are from the package hunspell
nameCheck <- hunspell_check( taxaCar , dict = dictio )
nameSuggest <- hunspell_suggest( taxaCar , dict = dictio )
# This part of the function change the wrong names to correct
# the user is provided with an interactive selection interface with select.list
wrongName <- as.list( taxaCar ) # vector of wrong taxa names
for( i in 1:length( nameSuggest ) ){
nameSuggest[[ i ]] <- c( wrongName[[ i ]] , nameSuggest[[ i ]]  )
nameSuggest[[i]] <- gsub( "_" , " " , unlist(nameSuggest[[i]]) )
}
nameSuggest
}
bioImport.1 <- function( x , group = "mi" , dfref = NULL ){
# set the reference database for the specified group
if( identical( group , "mi" ) ){
ref <- mi_ref
}
if( identical( group , "mf" ) ){
ref <- mf_ref
}
if( is.data.frame( dfref ) ){
ref <- dfref
}
x$Taxa <- trimws( sapply( x$Taxa , capWords , USE.NAMES = F ) )
x <- aggregate( . ~ Taxa , x , FUN = sum )
taxa_check <- unique( unlist( ref ) )
taxa_check <- as.character( taxa_check[ taxa_check != "" ] )
wrong_names <- x[ ! x[ , "Taxa" ] %in% taxa_check  , "Taxa" ]
if( length( wrong_names ) == 0 ){
wrong_names
} else {
custom <- FALSE
if( is.data.frame( dfref ) ){
custom <- TRUE
}
suggestNamesBio( wrong_names , custom = custom , group = group )
}
}
bioImport.1(DF)
load("/Users/tommasocancellario/Downloads/sysdata.rda")
DF_init <- read.csv("./Desktop/GitHub/biomonitoR_app/biomonitoR_app/macro_ex.csv", header = TRUE, sep = ",")
head(DF_init)
DF <- DF_init
bioImp <- bioImport(DF, group = "mi")
bioImp
bioImport.1 <- function( x , group = "mi" , dfref = NULL ){
# set the reference database for the specified group
if( identical( group , "mi" ) ){
ref <- mi_ref
}
if( identical( group , "mf" ) ){
ref <- mf_ref
}
if( is.data.frame( dfref ) ){
ref <- dfref
}
x$Taxa <- trimws( sapply( x$Taxa , capWords , USE.NAMES = F ) )
x <- aggregate( . ~ Taxa , x , FUN = sum )
taxa_check <- unique( unlist( ref ) )
taxa_check <- as.character( taxa_check[ taxa_check != "" ] )
wrong_names <- x[ ! x[ , "Taxa" ] %in% taxa_check  , "Taxa" ]
if( length( wrong_names ) == 0 ){
wrong_names
} else {
custom <- FALSE
if( is.data.frame( dfref ) ){
custom <- TRUE
}
suggestNamesBio( wrong_names , custom = custom , group = group )
}
}
capWords <- function( x ) {
# see ?tolower
cap <- paste( toupper( substring( x , 1 , 1 ) ), tolower( substring( x , 2 ) ),
sep = "" , collapse = " " )
}
suggestNamesBio <- function( x , custom = F , group = group , ... ){
# set the path of the dictionary. If group is mi or mf the dictionary is stored in the package path
# while if group is set to custom the dictionary is created in the user directory.
# the check of the names relies on the package hunspell
if( custom == F ){
if( group == "mi" ){
dic.path <- system.file( "dict" , "mi_dictionary.txt", package = "biomonitorweb" )
# very important to set cache equal to FALSE, otherwise suggestNames will provide inconsistent results.
dictio <- dictionary( dic.path, cache = F )
}
if( group == "mf" ){
dic.path <- system.file( "dict" , "mf_dictionary.txt" , package = "biomonitorweb" )
dictio <- dictionary( dic.path , cache = F )
}
if( group == "fi" ){
dic.path <- system.file( "dict" , "fi_dictionary.txt" , package = "biomonitorweb" )
dictio <- dictionary( dic.path , cache = F )
}
}
if( custom == T ){
dic.path <- c( paste(getwd() , "/custom_dictio.dic" , sep = "" ) )
dictio <- dictionary( dic.path , cache = F )
}
# get unique names present in the taxa list
taxaCar <- unique( as.character( x ) )
# replace space with underscore to be compatible with hunspell
taxaCar <- gsub( " " , '_' , taxaCar )
# nameCheck and nameSuggest check for the wrong names and suggest for correct names.
# hunspell_check and hunspell_suggest are from the package hunspell
nameCheck <- hunspell_check( taxaCar , dict = dictio )
nameSuggest <- hunspell_suggest( taxaCar , dict = dictio )
# This part of the function change the wrong names to correct
# the user is provided with an interactive selection interface with select.list
wrongName <- as.list( taxaCar ) # vector of wrong taxa names
for( i in 1:length( nameSuggest ) ){
nameSuggest[[ i ]] <- c( wrongName[[ i ]] , nameSuggest[[ i ]]  )
nameSuggest[[i]] <- gsub( "_" , " " , unlist(nameSuggest[[i]]) )
}
nameSuggest
}
bioImport.1 <- function( x , group = "mi" , dfref = NULL ){
# set the reference database for the specified group
if( identical( group , "mi" ) ){
ref <- mi_ref
}
if( identical( group , "mf" ) ){
ref <- mf_ref
}
if( is.data.frame( dfref ) ){
ref <- dfref
}
x$Taxa <- trimws( sapply( x$Taxa , capWords , USE.NAMES = F ) )
x <- aggregate( . ~ Taxa , x , FUN = sum )
taxa_check <- unique( unlist( ref ) )
taxa_check <- as.character( taxa_check[ taxa_check != "" ] )
wrong_names <- x[ ! x[ , "Taxa" ] %in% taxa_check  , "Taxa" ]
if( length( wrong_names ) == 0 ){
wrong_names
} else {
custom <- FALSE
if( is.data.frame( dfref ) ){
custom <- TRUE
}
suggestNamesBio( wrong_names , custom = custom , group = group )
}
}
bioImport.1(DF)
bioImport(DF, group = "mi")
shiny::runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
runApp('Desktop/GitHub/biomonitoR_app/biomonitoR_app')
install.packages("envirem")
ciataion("caper")
ciatation("caper")
citation("caper")
library(envirem)
shiny::runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
shinyApp(
ui = fluidPage(
sliderInput("slider", "Slider", 1, 100, 50),
downloadButton("report", "Generate report")
),
server = function(input, output) {
output$report <- downloadHandler(
# For PDF output, change this to "report.pdf"
filename = "report.html",
content = function(file) {
# Copy the report file to a temporary directory before processing it, in
# case we don't have write permissions to the current working dir (which
# can happen when deployed).
tempReport <- file.path(tempdir(), "report.Rmd")
file.copy("report.Rmd", tempReport, overwrite = TRUE)
# Set up parameters to pass to Rmd document
params <- list(n = input$slider)
# Knit the document, passing in the `params` list, and eval it in a
# child of the global environment (this isolates the code in the document
# from the code in this app).
rmarkdown::render(tempReport, output_file = file,
params = params,
envir = new.env(parent = globalenv())
)
}
)
}
)
ui <- fluidPage(
# Application title
titlePanel("RMD example"),
downloadButton("btn", "Generate Report")
)
# Define server logic required to draw a histogram
server <- function(input, output) {
data <- reactive({
mtcars
})
output$btn <- downloadHandler(
filename = function(){"myreport.docx"},
content = function(file) {
tempReport <- file.path(tempdir(),"markdown.Rmd")
file.copy("markdown.Rmd", tempReport, overwrite = TRUE)
rmarkdown::render("markdown.Rmd", output_format = "word_document", output_file = file,
params = list(table = data()), # here I'm passing data in params
envir = new.env(parent = globalenv()),clean=F,encoding="utf-8"
)
}
)
}
# Run the application
shinyApp(ui = ui, server = server)
img <- readPNG("./data/italy_sea.png")
library(png)
img <- readPNG("./data/italy_sea.png")
img <- readPNG("./Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel/data/italy_sea.png")
img <- rasterGrob(img)
img
plot(img)
library(png)
library(gridExtra)
library(ggplot2)
library(gtable)
library(RCurl) # just to load image from URL
img0 <- readPNG(getURLContent('http://i.stack.imgur.com/3anUH.png'))
img1 <- readPNG(getURLContent('http://i.stack.imgur.com/3anUH.png'))
grob0 <- rasterGrob(img0)
grob1 <- rasterGrob(img1)
p <- ggplot(subset(mpg,manufacturer=='audi'|manufacturer=='toyota'),aes(x=cty,y=displ))+facet_grid(year~manufacturer)+geom_point()
p
plot(p)
library(png)
library(gridExtra)
library(ggplot2)
library(gtable)
library(RCurl) # just to load image from URL
#Loading images
img0 <- readPNG(getURLContent('http://i.stack.imgur.com/3anUH.png'))
img1 <- readPNG(getURLContent('http://i.stack.imgur.com/3anUH.png'))
img0
grob0 <- rasterGrob(img0)
grob1 <- rasterGrob(img1)
grob0
grob0 <- rasterGrob(img0)
library(grid)
#Convert images to Grob (graphical objects)
grob0 <- rasterGrob(img0)
grob1 <- rasterGrob(img1)
# create the plot with data
p <- ggplot(subset(mpg,manufacturer=='audi'|manufacturer=='toyota'),aes(x=cty,y=displ))+facet_grid(year~manufacturer)+geom_point()
p
mytable <- ggplot_gtable(ggplot_build(p))
mytable
mytable <- gtable_add_rows(mytable, mytable$height[[4]], 3)
mytable
plot(mytable)
mytable <- gtable_add_grob(mytable,grob0,4,4, name = paste(runif(1)))
mytable <- gtable_add_grob(mytable,grob1,4,6, name = paste(runif(1)))
grid.draw(mytable)
#rendering
grid.draw(mytable)
mytable <- gtable_add_grob(mytable,grob0,4,4, name = paste(runif(1)))
grid.draw(mytable)
shiny::runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
ter.df <-
as.data.frame(t(
data.frame(
R1 = 10, # Piemonte
R2 = 50, # Valle d'Aosta
R3 = 0, # Lombardia
R4 = 0, # Trentino-Alto Adige
R5 = 0, # Veneto
R6 = 0, # Friuli-Venezia Giulia
R7 = 0, # Liguria
R8 = 0, # Emilia-Romagna
R9 = 0, # Toscana
R10 = 0, # Umbria
R11 = 0, # Marche
R12 = 0, # Lazio
R13 = 0, # Abruzzo
R14 = 0, # Molise
R15 = 0, # Campania
R16 = 0, # Puglia
R17 = 0, # Basilicata
R18 = 0, # Calabria
R19 = 0, # Sicilia
R20 = 0, # Sardegna
R21 = 0, # Vatican City
R22 = 0 # San Marino
)
))
ter.df
colnames(ter.df) <- "richness"
ter.df$ID <- rownames(ter.df)
it <- st_read("./data/Italy/Italy_complete.shp")
it <- merge(it, ter.df, by = "ID") # Merge shapefile with richness data
library(ggplot2)
library(sf)
it <- st_read("./data/Italy/Italy_complete.shp")
it <- merge(it, ter.df, by = "ID") # Merge shapefile with richness data
it <- st_read("./Desktop/GitHub/biomapper_1.0_html_intel/data/Italy/Italy_complete.shp")
it <- merge(it, ter.df, by = "ID") # Merge shapefile with richness data
it <- st_read("./Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel/data/Italy/Italy_complete.shp")
it <- merge(it, ter.df, by = "ID") # Merge shapefile with richness data
it
ggplot() +
geom_sf(data = it, aes(fill = richness), colour = "black") +
scale_fill_distiller(
"Terrestrial richness",
type = "seq",
direction = 1,
palette = "Greys"
)
ggplot() +
geom_sf(data = it, aes(fill = richness), colour = "black") +
scale_fill_distiller(
"Terrestrial richness",
type = "seq",
direction = 1,
palette = "Greys"
) +
theme_bw() +
theme(
axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.ticks = element_blank(),
rect = element_blank(),
panel.background = element_rect(fill = "transparent"),
panel.grid.major = element_line(color = "transparent"),
legend.position = "bottom"
) +
ggtitle("Terrestrial richness")
img <- readPNG("./Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel/data/italy_sea.png")
library(png) # Load img
g1 <- tableGrob(ter.reactive()[1:11, 2:1],
rows = NULL,
theme = ttheme_minimal(base_size = 8))
g2 <- tableGrob(ter.reactive()[12:22, 2:1],
rows = NULL,
theme = ttheme_minimal(base_size = 8))
library(gridExtra)
library(grid)
g1 <- tableGrob(ter.reactive()[1:11, 2:1],
rows = NULL,
theme = ttheme_minimal(base_size = 8))
g2 <- tableGrob(ter.reactive()[12:22, 2:1],
rows = NULL,
theme = ttheme_minimal(base_size = 8))
g1 <- tableGrob(ter.df[1:11, 2:1],
rows = NULL,
theme = ttheme_minimal(base_size = 8))
g2 <- tableGrob(ter.df[12:22, 2:1],
rows = NULL,
theme = ttheme_minimal(base_size = 8))
haligned <- gtable_combine(g1, g2, along = 1)
title.grob <- textGrob(
label = "Terrestial richness",
x = unit(0, "lines"),
y = unit(0, "lines"),
hjust = 0,
vjust = 0,
gp = gpar(fontsize = 12)
)
p1 <- ggplot() +
geom_sf(data = it, aes(fill = richness), colour = "black") +
scale_fill_distiller(
"Terrestrial richness",
type = "seq",
direction = 1,
palette = "Greys"
) +
theme_bw() +
theme(
axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.ticks = element_blank(),
rect = element_blank(),
panel.background = element_rect(fill = "transparent"),
panel.grid.major = element_line(color = "transparent"),
legend.position = "bottom"
) +
ggtitle("Terrestrial richness")
grid.arrange(
p1,
rasterGrob(img),
arrangeGrob(haligned, top = title.grob),
layout_matrix = rbind(c(1, 1, 2),
c(1, 1, 3))
)
img <- readPNG("./Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel/data/italy_sea.png")
grid.arrange(
p1,
rasterGrob(img),
arrangeGrob(haligned, top = title.grob),
layout_matrix = rbind(c(1, 1, 2),
c(1, 1, 3))
)
shiny::runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
dev.off()
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
DF_init <- data.frame(readxl::read_excel("./Desktop/Example.xlsx", sheet = 1))
DF_init
it <- st_read("./Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel/data/Italy/Italy_complete.shp")
it
it <- merge(it, DF_init, by = "ID") # Merge shapefile with richness data
it
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
mar.df <- as.data.frame(t(
data.frame(
M1 = 1, # Sector 1
M2 = 10, # Sector 2
M3 = 0, # Sector 3
M4 = 0, # Sector 4
M5 = 0, # Sector 5
M6 = 5, # Sector 6
M7 = 0, # Sector 7
M8 = 0, # Sector 8
M9 = 0  # Sector 9
)
))
mar.df
colnames(mar.df) <- "richness"
mar.df$ID <- rownames(mar.df)
mar.df
DF_init <- data.frame(readxl::read_excel("./Desktop/Example.xlsx", sheet = 1))
DF_init
DF_init[ ,c(2,3,1)]
DF_init <- data.frame(readxl::read_excel("./Desktop/Example.xlsx", sheet = 1))
head(DF_init)
DF_init[ ,c(3,2)]
DF_init <- DF_init[ ,c(3,2)]
row.names(DF_init) <- DF_init$ID
head(DF_init)
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
shiny::runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
runApp('Desktop/GitHub/biomapper_1.0_html_intel/biomapper_1.0_html_intel')
install.packages(c("antiword", "ape", "BAT", "bookdown", "brew", "caret", "cli", "clipr", "colorspace", "commonmark", "compareDF", "conquer", "crayon", "cubature", "datawizard", "desc", "doParallel", "doSNOW", "dplyr", "DT", "emdist", "emmeans", "evaluate", "fansi", "filehash", "future", "geojsonsf", "ggdendro", "ggnewscale", "glue", "gmp", "gower", "gstat", "imager", "insight", "iterators", "jqr", "jsonlite", "knitr", "ks", "leaflet", "linprog", "lme4", "lmtest", "locfit", "magic", "maptools", "MASS", "Matrix", "mgcv", "MuMIn", "ngram", "nlme", "openssl", "parameters", "parsedate", "pdftools", "plyr", "pracma", "PresenceAbsence", "processx", "psych", "quantreg", "randomForest", "Rcpp", "RCurl", "recipes", "rgbif", "rgdal", "rgrass7", "rlang", "rmarkdown", "RSQLite", "sass", "see", "sf", "shinyWidgets", "spatstat", "spatstat.core", "spatstat.geom", "spatstat.linnet", "stplanr", "survival", "svglite", "systemfonts", "terra", "tidyr", "tidyselect", "tmap", "units", "uuid", "V8", "waldo", "withr", "xfun", "XML", "yaml"))
install.packages(c("antiword", "ape", "BAT", "bookdown", "brew", "caret", "cli", "clipr", "colorspace", "commonmark", "compareDF", "conquer", "crayon", "cubature", "datawizard", "desc", "doParallel", "doSNOW", "dplyr", "DT", "emdist", "emmeans", "evaluate", "fansi", "filehash", "future", "geojsonsf", "ggdendro", "ggnewscale", "glue", "gmp", "gower", "gstat", "imager", "insight", "iterators", "jqr", "jsonlite", "knitr", "ks", "leaflet", "linprog", "lme4", "lmtest", "locfit", "magic", "maptools", "MASS", "Matrix", "mgcv", "MuMIn", "ngram", "nlme", "openssl", "parameters", "parsedate", "pdftools", "plyr", "pracma", "PresenceAbsence", "processx", "psych", "quantreg", "randomForest", "Rcpp", "RCurl", "recipes", "rgbif", "rgdal", "rgrass7", "rlang", "rmarkdown", "RSQLite", "sass", "see", "sf", "shinyWidgets", "spatstat", "spatstat.core", "spatstat.geom", "spatstat.linnet", "stplanr", "survival", "svglite", "systemfonts", "terra", "tidyr", "tidyselect", "tmap", "units", "uuid", "V8", "waldo", "withr", "xfun", "XML", "yaml"))
install.packages(c("antiword", "ape", "BAT", "bookdown", "brew", "caret", "cli", "clipr", "colorspace", "commonmark", "compareDF", "conquer", "crayon", "cubature", "datawizard", "desc", "doParallel", "doSNOW", "dplyr", "DT", "emdist", "emmeans", "evaluate", "fansi", "filehash", "future", "geojsonsf", "ggdendro", "ggnewscale", "glue", "gmp", "gower", "gstat", "imager", "insight", "iterators", "jqr", "jsonlite", "knitr", "ks", "leaflet", "linprog", "lme4", "lmtest", "locfit", "magic", "maptools", "MASS", "Matrix", "mgcv", "MuMIn", "ngram", "nlme", "openssl", "parameters", "parsedate", "pdftools", "plyr", "pracma", "PresenceAbsence", "processx", "psych", "quantreg", "randomForest", "Rcpp", "RCurl", "recipes", "rgbif", "rgdal", "rgrass7", "rlang", "rmarkdown", "RSQLite", "sass", "see", "sf", "shinyWidgets", "spatstat", "spatstat.core", "spatstat.geom", "spatstat.linnet", "stplanr", "survival", "svglite", "systemfonts", "terra", "tidyr", "tidyselect", "tmap", "units", "uuid", "V8", "waldo", "withr", "xfun", "XML", "yaml"))
install.packages(c("antiword", "ape", "BAT", "bookdown", "brew", "caret", "cli", "clipr", "colorspace", "commonmark", "compareDF", "conquer", "crayon", "cubature", "datawizard", "desc", "doParallel", "doSNOW", "dplyr", "DT", "emdist", "emmeans", "evaluate", "fansi", "filehash", "future", "geojsonsf", "ggdendro", "ggnewscale", "glue", "gmp", "gower", "gstat", "imager", "insight", "iterators", "jqr", "jsonlite", "knitr", "ks", "leaflet", "linprog", "lme4", "lmtest", "locfit", "magic", "maptools", "MASS", "Matrix", "mgcv", "MuMIn", "ngram", "nlme", "openssl", "parameters", "parsedate", "pdftools", "plyr", "pracma", "PresenceAbsence", "processx", "psych", "quantreg", "randomForest", "Rcpp", "RCurl", "recipes", "rgbif", "rgdal", "rgrass7", "rlang", "rmarkdown", "RSQLite", "sass", "see", "sf", "shinyWidgets", "spatstat", "spatstat.core", "spatstat.geom", "spatstat.linnet", "stplanr", "survival", "svglite", "systemfonts", "terra", "tidyr", "tidyselect", "tmap", "units", "uuid", "V8", "waldo", "withr", "xfun", "XML", "yaml"))
install.packages(c("antiword", "ape", "BAT", "bookdown", "brew", "caret", "cli", "clipr", "colorspace", "commonmark", "compareDF", "conquer", "crayon", "cubature", "datawizard", "desc", "doParallel", "doSNOW", "dplyr", "DT", "emdist", "emmeans", "evaluate", "fansi", "filehash", "future", "geojsonsf", "ggdendro", "ggnewscale", "glue", "gmp", "gower", "gstat", "imager", "insight", "iterators", "jqr", "jsonlite", "knitr", "ks", "leaflet", "linprog", "lme4", "lmtest", "locfit", "magic", "maptools", "MASS", "Matrix", "mgcv", "MuMIn", "ngram", "nlme", "openssl", "parameters", "parsedate", "pdftools", "plyr", "pracma", "PresenceAbsence", "processx", "psych", "quantreg", "randomForest", "Rcpp", "RCurl", "recipes", "rgbif", "rgdal", "rgrass7", "rlang", "rmarkdown", "RSQLite", "sass", "see", "sf", "shinyWidgets", "spatstat", "spatstat.core", "spatstat.geom", "spatstat.linnet", "stplanr", "survival", "svglite", "systemfonts", "terra", "tidyr", "tidyselect", "tmap", "units", "uuid", "V8", "waldo", "withr", "xfun", "XML", "yaml"))
